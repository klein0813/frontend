{"version":3,"sources":["webpack:///webpack/bootstrap 50bc8adf202b5b0dc194","webpack:///./src/pages/ar/web.worker.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","colorTracker","self","addEventListener","e","data","cmd","[object Object]","optColor","windowWidth","windowHeight","this","neighboursI","Int32Array","neighboursJ","neighbours_","color","minDimension","maxDimension","minGroupSize","cloud","total","maxx","maxy","minx","Infinity","miny","x","y","width","height","neighbours","rects","intersects","results","getMinDimension","getMaxDimension","r","length","r1","r2","x0","y0","x1","y1","x2","y2","x3","y3","Math","min","max","push","pixels","result","trackColor_","tmpIndex","tmpWidth","forEach","rect","index","currGroupSize","currI","currJ","currW","queuePosition","currGroup","marked","Int8Array","getMinGroupSize","neighboursW","getNeighboursForWidth_","queue","w","j","g","b","k","otherW","otherI","otherJ","calculateDimensions_","mergeRectangles_","msg","track","postMessage","close"],"mappings":"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","file":"Worker.50bc8adf202b5b0dc194.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"./\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"POsN\");\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 50bc8adf202b5b0dc194","let colorTracker\r\n\r\nself.addEventListener('message', function (e) {\r\n  var data = e.data\r\n  switch (data.cmd) {\r\n    case 'init':\r\n      colorTracker = new ColorTracker('co_brown', data.msg.windowWidth, data.msg.windowHeight)\r\n      break\r\n    case 'start':\r\n      const { color } = colorTracker.track(data.msg.pixels, data.msg.width, data.msg.height)\r\n      self.postMessage(color === 'co_brown' ? 'bottle' : 'can')\r\n      break\r\n    case 'stop':\r\n      self.close()\r\n      break\r\n    default:\r\n      self.postMessage('Unknown command: ' + data.msg)\r\n  }\r\n}, false)\r\n\r\n/**\r\n * Tests if a rectangle intersects with another.\r\n *\r\n *  <pre>\r\n *  x0y0 --------       x2y2 --------\r\n *      |       |           |       |\r\n *      -------- x1y1       -------- x3y3\r\n * </pre>\r\n *\r\n * @param {number} x0 Horizontal coordinate of P0.\r\n * @param {number} y0 Vertical coordinate of P0.\r\n * @param {number} x1 Horizontal coordinate of P1.\r\n * @param {number} y1 Vertical coordinate of P1.\r\n * @param {number} x2 Horizontal coordinate of P2.\r\n * @param {number} y2 Vertical coordinate of P2.\r\n * @param {number} x3 Horizontal coordinate of P3.\r\n * @param {number} y3 Vertical coordinate of P3.\r\n * @return {boolean}\r\n */\r\nfunction intersectRect (x0, y0, x1, y1, x2, y2, x3, y3) {\r\n  return !(x2 > x1 || x3 < x0 || y2 > y1 || y3 < y0)\r\n}\r\n\r\nfunction brownColorCheck (r, g, b) {\r\n  return r <= 64 && r - g > 16 && g > b\r\n}\r\n\r\nclass ColorTracker {\r\n  constructor (optColor, windowWidth, windowHeight) {\r\n    this.neighboursI = new Int32Array([-1, -1, 0, 1, 1, 1, 0, -1])\r\n    this.neighboursJ = new Int32Array([0, 1, 1, 1, 0, -1, -1, -1])\r\n    this.neighbours_ = {}\r\n    this.color = 'co_brown'\r\n    this.minDimension = 48\r\n    this.maxDimension = 0.9 * windowWidth\r\n    this.minGroupSize = 48 * 48\r\n    this.color = optColor || this.color\r\n    this.windowWidth = windowWidth\r\n    this.windowHeight = windowHeight\r\n  }\r\n\r\n  calculateDimensions_ (cloud, total) {\r\n    let maxx = -1\r\n    let maxy = -1\r\n    let minx = Infinity\r\n    let miny = Infinity\r\n\r\n    for (let c = 0; c < total; c += 2) {\r\n      const x = cloud[c]\r\n      const y = cloud[c + 1]\r\n\r\n      if (x < minx) {\r\n        minx = x\r\n      }\r\n      if (x > maxx) {\r\n        maxx = x\r\n      }\r\n      if (y < miny) {\r\n        miny = y\r\n      }\r\n      if (y > maxy) {\r\n        maxy = y\r\n      }\r\n    }\r\n\r\n    return {\r\n      width: maxx - minx,\r\n      height: maxy - miny,\r\n      x: minx,\r\n      y: miny,\r\n      maxx,\r\n      maxy\r\n    }\r\n  }\r\n\r\n  getMinDimension () {\r\n    return this.minDimension\r\n  }\r\n\r\n  getMaxDimension () {\r\n    return this.maxDimension\r\n  }\r\n\r\n  getMinGroupSize () {\r\n    return this.minGroupSize\r\n  }\r\n\r\n  getNeighboursForWidth_ (width) {\r\n    if (this.neighbours_[width]) {\r\n      return this.neighbours_[width]\r\n    }\r\n\r\n    const neighbours = new Int32Array(8)\r\n\r\n    neighbours[0] = -width * 4\r\n    neighbours[1] = -width * 4 + 4\r\n    neighbours[2] = 4\r\n    neighbours[3] = width * 4 + 4\r\n    neighbours[4] = width * 4\r\n    neighbours[5] = width * 4 - 4\r\n    neighbours[6] = -4\r\n    neighbours[7] = -width * 4 - 4\r\n\r\n    this.neighbours_[width] = neighbours\r\n\r\n    return neighbours\r\n  }\r\n\r\n  /**\r\n   * Unites groups whose bounding box intersect with each other.\r\n   * @param {Array.<Object>} rects\r\n   * @private\r\n   */\r\n  mergeRectangles_ (rects) {\r\n    let intersects\r\n    let results = []\r\n    const minDimension = this.getMinDimension()\r\n    const maxDimension = this.getMaxDimension()\r\n\r\n    for (let r = 0; r < rects.length; r++) {\r\n      let r1 = rects[r]\r\n      intersects = true\r\n      for (let s = r + 1; s < rects.length; s++) {\r\n        let r2 = rects[s]\r\n        if (intersectRect(r1.x, r1.y, r1.x + r1.width, r1.y + r1.height, r2.x, r2.y, r2.x + r2.width, r2.y + r2.height)) {\r\n          intersects = false\r\n          let x1 = Math.min(r1.x, r2.x)\r\n          let y1 = Math.min(r1.y, r2.y)\r\n          let x2 = Math.max(r1.x + r1.width, r2.x + r2.width)\r\n          let y2 = Math.max(r1.y + r1.height, r2.y + r2.height)\r\n          r2.height = y2 - y1\r\n          r2.width = x2 - x1\r\n          r2.x = x1\r\n          r2.y = y1\r\n          break\r\n        }\r\n      }\r\n\r\n      if (intersects) {\r\n        if (r1.width >= minDimension && r1.height >= minDimension) {\r\n          if (r1.width <= maxDimension && r1.height <= maxDimension) {\r\n            results.push(r1)\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return results\r\n  }\r\n\r\n  track (pixels, width, height) {\r\n    let result = this.trackColor_(pixels, width, height, this.color)\r\n    let tmpIndex = -1\r\n    let tmpWidth = -1\r\n    result.forEach((rect, index) => {\r\n      if (rect.width > tmpWidth) {\r\n        tmpWidth = rect.width\r\n        tmpIndex = index\r\n      }\r\n    })\r\n    return tmpIndex === -1 ? {} : result[tmpIndex]\r\n  }\r\n\r\n  trackColor_ (pixels, width, height) {\r\n    let currGroup = new Int32Array(pixels.length >> 2)\r\n    let currGroupSize\r\n    let currI\r\n    let currJ\r\n    let currW\r\n    let marked = new Int8Array(pixels.length)\r\n    let minGroupSize = this.getMinGroupSize()\r\n    let neighboursW = this.getNeighboursForWidth_(width)\r\n    let queue = new Int32Array(pixels.length)\r\n    let queuePosition\r\n    let results = []\r\n    let w = -4\r\n\r\n    for (let i = 0; i < height; i++) {\r\n      for (let j = 0; j < width; j++) {\r\n        w += 4\r\n\r\n        if (marked[w]) {\r\n          continue\r\n        }\r\n\r\n        currGroupSize = 0\r\n        queuePosition = -1\r\n        queue[++queuePosition] = w\r\n        queue[++queuePosition] = i\r\n        queue[++queuePosition] = j\r\n        marked[w] = 1\r\n\r\n        while (queuePosition >= 0) {\r\n          currJ = queue[queuePosition--]\r\n          currI = queue[queuePosition--]\r\n          currW = queue[queuePosition--]\r\n\r\n          if (brownColorCheck(pixels[currW], pixels[currW + 1], pixels[currW + 2], pixels[currW + 3], currW, currI, currJ)) {\r\n            currGroup[currGroupSize++] = currJ\r\n            currGroup[currGroupSize++] = currI\r\n\r\n            for (let k = 0; k < neighboursW.length; k++) {\r\n              let otherW = currW + neighboursW[k]\r\n              let otherI = currI + this.neighboursI[k]\r\n              let otherJ = currJ + this.neighboursJ[k]\r\n              if (!marked[otherW] && otherI >= 0 && otherI < height && otherJ >= 0 && otherJ < width) {\r\n                queue[++queuePosition] = otherW\r\n                queue[++queuePosition] = otherI\r\n                queue[++queuePosition] = otherJ\r\n                marked[otherW] = 1\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        if (currGroupSize >= minGroupSize) {\r\n          let data = this.calculateDimensions_(currGroup, currGroupSize)\r\n          if (data.width >= 48 && data.height >= 48 && data.width < 0.9 * this.windowWidth && data.height < 0.9 * this.windowHeight) {\r\n            results.push(data)\r\n            data.color = this.color\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return this.mergeRectangles_(results)\r\n  }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/eslint-loader??ref--0!./src/pages/ar/web.worker.js\n// module id = POsN\n// module chunks = 0"],"sourceRoot":""}