<!DOCTYPE html>
  <head>
    <title>Light Model</title>
  </head>
  <body>
    <canvas id="canvas" width="500" height="500" style="background-color: black;"></canvas>
    <script>
      const canvas = document.getElementById('canvas');
      const gl = canvas.getContext('webgl');
      const vertexShaderSource = `
        attribute vec4 apos;
        attribute vec2 a_texCoord;
        varying vec2 v_texCoord;

        void main () {
          gl_Position = apos;
          v_texCoord = a_texCoord;
        }
      `;
      const fragShaderSource = `
        precision highp float;
        varying vec2 v_texCoord;
        uniform sampler2D u_sampler;

        void main () {
          gl_FragColor = texture2D(u_sampler, v_texCoord);
        }
      `;

      const vertexShader = gl.createShader(gl.VERTEX_SHADER);
      const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(vertexShader, vertexShaderSource);
      gl.shaderSource(fragmentShader, fragShaderSource);
      gl.compileShader(vertexShader);
      gl.compileShader(fragmentShader);
      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      gl.useProgram(program);
      
      const attribData = new Float32Array([
        -.5, 0.5, // 顶点坐标数据 左上角
        0, 1.0, // UV纹理坐标数据 左上角——uv0
        0.5, 0.5,
        1.0, 1.0,
        -.5, -.5,
        0, 0,
        0.5, -.5,
        1.0, 0
      ]);

      const attribBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, attribBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, attribData, gl.STATIC_DRAW);
      const aposAttrib = gl.getAttribLocation(program, 'apos');
      gl.vertexAttribPointer(aposAttrib, 2, gl.FLOAT, false, 4 * 4, 0);
      gl.enableVertexAttribArray(aposAttrib);
      const texCoordAttrib = gl.getAttribLocation(program, 'a_texCoord');
      gl.vertexAttribPointer(texCoordAttrib, 2, gl.FLOAT, false, 4 * 4, 4 * 2);
      gl.enableVertexAttribArray(texCoordAttrib);
      
      const image = new Image();
      image.onload = loadTexture;
      image.src = './texture.jpg';
      function loadTexture () {
        const textureBuffer = gl.createTexture(); // 创建纹理图像缓冲区
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true); //纹理图片上下反转
        gl.activeTexture(gl.TEXTURE1);//激活0号纹理单元TEXTURE0
        gl.bindTexture(gl.TEXTURE_2D, textureBuffer); // 将纹理缓冲区绑定到纹理单元的 TEXTURE_2D部分
        // 设置纹理贴图填充方式(纹理贴图像素尺寸大于顶点绘制区域像素尺寸)
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        // 设置纹理贴图填充方式(纹理贴图像素尺寸小于顶点绘制区域像素尺寸)
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        //将图像写入纹理缓冲区，设置纹素格式，jpg格式对应gl.RGB
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image);
        const samplerUniform = gl.getUniformLocation(program, 'u_sampler');
        gl.uniform1i(samplerUniform, 1); // 纹理缓冲区单元TEXTURE0中的颜色数据传入片元着色器

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }
    </script>
  </body>
</html>
