<!DOCTYPE html>
  <head>
    <title>Switch shader program</title>
    <script src="../libs/baidu_tongji.js"></script>
  </head>
  <body>
    <canvas id="canvas" width="500" height="500" style="background-color: black;"></canvas>
    <script>
      const canvas = document.getElementById('canvas');
      const gl = canvas.getContext('webgl');
      const cubeVertexShaderSource = `
        varying vec4 v_color;
        attribute vec4 apos;
        attribute vec4 a_color;
        attribute vec4 a_normal;
        uniform vec3 u_lightPosition;
        uniform vec3 u_lightColor;
        uniform mat4 rmx;
        uniform mat4 rmy;

        void main () {
          gl_Position = rmx * rmy * apos;
          vec3 lightDirection = normalize(gl_Position.xyz - u_lightPosition);
          vec3 normal = normalize(vec3(rmx * rmy * a_normal));
          float dotcos = max(dot(lightDirection, normal), 0.0);
          vec3 reflectedLight = u_lightColor * a_color.rgb * dotcos;
          v_color = vec4(reflectedLight, a_color.a);
        }
      `;
      const cubeFragShaderSource = `
        precision lowp float;
        varying vec4 v_color;

        void main () {
          gl_FragColor = v_color;
        }
      `;
      const texVertexShaderSource = `
        varying vec2 v_texCoord;
        attribute vec4 apos;
        attribute vec2 a_texCoord;
        uniform mat4 rmx;
        uniform mat4 rmy;

        void main () {
          gl_Position = rmx * rmy * apos;
          v_texCoord = a_texCoord;
        }
      `;
      const texFragShaderSource = `
        precision highp float;
        varying vec2 v_texCoord;
        uniform sampler2D a_sampler;

        void main () {
          gl_FragColor = texture2D(a_sampler, v_texCoord); 
        }
      `;
      const initShader = (vertexShaderSource, fragShaderSource) => {
        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(vertexShader, vertexShaderSource);
        gl.shaderSource(fragmentShader, fragShaderSource);
        gl.compileShader(vertexShader);
        gl.compileShader(fragmentShader);
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        return program;
      }
      const vertexBuffer = (attrib, bufferData, size) => {
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, bufferData, gl.STATIC_DRAW);
        gl.vertexAttribPointer(attrib, size, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(attrib);
      }
      const cubeAposData = new Float32Array([
        -.5,0.5,0.5, 0.5,0.5,0.5, -.5,-.5,0.5, 0.5,0.5,0.5, -.5,-.5,0.5, 0.5,-.5,0.5,
        -.5,0.5,-.5, 0.5,0.5,-.5, -.5,-.5,-.5, 0.5,0.5,-.5, -.5,-.5,-.5, 0.5,-.5,-.5,
        -.5,0.5,0.5, 0.5,0.5,0.5, 0.5,0.5,-.5, -.5,0.5,0.5, 0.5,0.5,-.5, -.5,0.5,-.5,
        -.5,-.5,0.5, 0.5,-.5,0.5, 0.5,-.5,-.5, -.5,-.5,0.5, 0.5,-.5,-.5, -.5,-.5,-.5,
        -.5,0.5,0.5, -.5,0.5,-.5, -.5,-.5,-.5, -.5,0.5,0.5, -.5,-.5,-.5, -.5,-.5,0.5,
        0.5,0.5,0.5, 0.5,0.5,-.5, 0.5,-.5,-.5, 0.5,0.5,0.5, 0.5,-.5,-.5, 0.5,-.5,0.5,
      ]);
      const cubeColorData = new Float32Array(108);
      for (let index = 0; index < cubeColorData.length; index += 3) {
        cubeColorData[index] = 1.0;
      }
      const cubeNormalData = new Float32Array([
        0,0,1, 0,0,1, 0,0,1, 0,0,1, 0,0,1, 0,0,1,
        0,0,-1, 0,0,-1, 0,0,-1, 0,0,-1, 0,0,-1, 0,0,-1,
        0,1,0, 0,1,0, 0,1,0, 0,1,0, 0,1,0, 0,1,0,
        0,-1,0, 0,-1,0, 0,-1,0, 0,-1,0, 0,-1,0, 0,-1,0,
        -1,0,0, -1,0,0, -1,0,0, -1,0,0, -1,0,0, -1,0,0,
        1,0,0, 1,0,0, 1,0,0, 1,0,0, 1,0,0, 1,0,0,
      ]);
      const texAposData = new Float32Array([ -.4,-.2,-.51, 0.4,-.2,-.51, -.4,0.2,-.51, 0.4,0.2,-.51 ]);
      const texCoordData = new Float32Array([ 0,0, 1,0, 0,1, 1,1 ]);
      const imgSrc = './webgl24glb.jpg';
      const cos30 = Math.cos(Math.PI / 6);
      const sin30 = Math.sin(Math.PI / 6);

      const cubeProgram = initShader(cubeVertexShaderSource, cubeFragShaderSource);
      const texProgram = initShader(texVertexShaderSource, texFragShaderSource);
      gl.useProgram(cubeProgram);
      const cubeAposAttrib = gl.getAttribLocation(cubeProgram, 'apos');
      const cubeColorAttrib = gl.getAttribLocation(cubeProgram, 'a_color');
      const cubeNormalAttrib = gl.getAttribLocation(cubeProgram, 'a_normal');
      vertexBuffer(cubeAposAttrib, cubeAposData, 3);
      vertexBuffer(cubeColorAttrib, cubeColorData, 3);
      vertexBuffer(cubeNormalAttrib, cubeNormalData, 3);
      const cubeRMX = gl.getUniformLocation(cubeProgram, 'rmx');
      const cubeRMY = gl.getUniformLocation(cubeProgram, 'rmy');
      const cubeLightPosition = gl.getUniformLocation(cubeProgram, 'u_lightPosition');
      const cubeLightColor = gl.getUniformLocation(cubeProgram, 'u_lightColor');
      gl.uniformMatrix4fv(cubeRMX, false, new Float32Array([ 1,0,0,0, 0,cos30,-sin30,0, 0, sin30, cos30, 0, 0, 0, 0, 1 ]));
      gl.uniformMatrix4fv(cubeRMY, false, new Float32Array([ cos30,0,-sin30,0, 0,1,0,0, sin30,0,cos30,0, 0,0,0,1 ]));
      gl.uniform3f(cubeLightPosition, 0, 0, 1);
      gl.uniform3f(cubeLightColor, 1.0, 1.0, 1.0);

      gl.enable(gl.DEPTH_TEST);
      gl.drawArrays(gl.TRIANGLES, 0, 36);

      gl.useProgram(texProgram);
      const texAposAttrib = gl.getAttribLocation(texProgram, 'apos');
      const texCoordAttrib = gl.getAttribLocation(texProgram, 'a_texCoord');
      const texRMX = gl.getUniformLocation(texProgram, 'rmx');
      const texRMY = gl.getUniformLocation(texProgram, 'rmy');
      vertexBuffer(texAposAttrib, texAposData, 3);
      vertexBuffer(texCoordAttrib, texCoordData, 2);
      gl.uniformMatrix4fv(texRMX, false, new Float32Array([ 1,0,0,0, 0,cos30,-sin30,0, 0, sin30, cos30, 0, 0, 0, 0, 1 ]));
      gl.uniformMatrix4fv(texRMY, false, new Float32Array([ cos30,0,-sin30,0, 0,1,0,0, sin30,0,cos30,0, 0,0,0,1 ]));
      const image = new Image();
      image.onload = loadTexture;
      image.src = imgSrc;

      function loadTexture () {
        const textureBuffer = gl.createTexture();
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, textureBuffer);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image);
        gl.enable(gl.DEPTH_TEST);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }
    </script>
  </body>
</html>
