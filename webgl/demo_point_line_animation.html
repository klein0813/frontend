<!DOCTYPE html>
  <head>
    <title>Point Line Animation</title>
    <style>
      html, body {
        padding: 0;
        margin: 0;
        width: 100vw;
        height: 100vh;
      }
    </style>
  </head>
  <body>
    <canvas id="webgl" width="500" height="500" style="background-color: grey;"></canvas>
    <script>
      const canvas = document.getElementById('webgl');
      canvas.width = document.documentElement.offsetWidth;
      canvas.height = document.documentElement.offsetHeight;
      const gl = canvas.getContext('webgl');
      const vertexShaderSource = `
        varying vec4 v_color;
        attribute vec4 apos;
        attribute float a_alpha;
        uniform vec3 u_fromColor;
        uniform vec3 u_toColor;
        uniform float u_pi;
        uniform float u_time;

        void main () {
          gl_Position = apos;
          if (abs(gl_Position.x) > 0.9999 && abs(gl_Position.y) > 0.9999) {
            vec3 color = (u_fromColor - u_toColor + 1.0) * u_time + u_toColor;
            v_color = vec4(color / 255.0, 1.0);
          } else {
            gl_PointSize = 5.0;
            v_color = vec4(1.0, 1.0, 1.0, 0.3);
          }
        }
      `;
      const fragShaderSource = `
        precision lowp float;
        varying vec4 v_color;

        void main () {
          if (v_color.a > 2.0) {
            float r = distance(gl_PointCoord, vec2(0.5, 0.5));
            if (r > 0.5) {
              discard;
            }
            gl_FragColor = vec4(vec3(v_color), 0.3);
          } else {
            gl_FragColor = v_color;
          }
        }
      `;
      const vertexShader = gl.createShader(gl.VERTEX_SHADER);
      const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(vertexShader, vertexShaderSource);
      gl.shaderSource(fragmentShader, fragShaderSource);
      gl.compileShader(vertexShader);
      gl.compileShader(fragmentShader);
      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      gl.useProgram(program);

      const nodeCount = 3;
      const aposData = new Float32Array([
        1, 1,
        -1, 1,
        -1, -1,
        1, -1, 
        ...new Array(nodeCount * 2).fill(2)
      ]);
      const aposAttrib = gl.getAttribLocation(program, 'apos');
      const aposBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, aposBuffer);
      gl.vertexAttribPointer(aposAttrib, 2, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(aposAttrib);

      const alphaData = new Float32Array(6 + nodeCount * nodeCount).fill(2);
      const alphaAttrib = gl.getAttribLocation(program, 'a_alpha');
      const alphaBuffer = gl.createBuffer();
      gl.vertexAttribPointer(alphaAttrib, 1, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(alphaAttrib);

      const fromColorUniform = gl.getUniformLocation(program, 'u_fromColor');
      const toColorUniform = gl.getUniformLocation(program, 'u_toColor');
      const piUniform = gl.getUniformLocation(program, 'u_pi');
      const timeUniform = gl.getUniformLocation(program, 'u_time');
      gl.uniform3f(fromColorUniform, 10, 25, 100);
      gl.uniform3f(toColorUniform, 25, 50, 150);
      gl.uniform1f(piUniform, Math.PI);
      
      const cw = canvas.width;
      const ch = canvas.height;
      const pointDatas = new Float32Array(nodeCount * 3);
      for (let i = 0; i < nodeCount * 3; i += 3) {
        pointDatas[i] = Math.floor(Math.random() * (cw - 0 + 1)) + 0;
        pointDatas[i + 1] = Math.floor(Math.random() * (ch - 0 + 1)) + 0;
        pointDatas[i + 2] = Math.random() * (Math.PI * 2 - 0 + 1) + 0;
      }
      // 设置索引
      const indexesData = new Uint8Array([
        0, 1, 2,
        0, 2, 3,
        ...new Array(nodeCount * nodeCount).fill(0)
      ]);
      let count = 6 + nodeCount;
      for (let i = 0; i < nodeCount; i++) {
        indexesData[6 + i] = 4 + i;
        for (let j = i + 1; j < nodeCount; j++) {
          indexesData[count] = 4 + i
          indexesData[count + 1] = 4 + j
          count += 2;
        }
      }
      console.log('count', count, nodeCount)
      const indexexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexexBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexesData, gl.STATIC_DRAW);
      console.log('indexesData', indexesData);
      let t0 = Date.now();
      let dt = 0;
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);
      // const initCount = 6 * 3 + nodeCount * 3;

      draw()
      function draw () {
        // let count = initCount;
        for (let i = 0, { length } = pointDatas; i < length; i = i + 3) {
          pointDatas[i] = pointDatas[i] + Math.cos(pointDatas[i + 2]) * 20 * (dt / 1000.0);
					pointDatas[i + 1] = pointDatas[i + 1] + Math.sin(pointDatas[i + 2]) * 20 * (dt / 1000.0);

          if (pointDatas[i] < 0) {
            pointDatas[i] = cw + (pointDatas[i] % cw);
          } else if (pointDatas[i] > cw) {
            pointDatas[i] = pointDatas[i] % cw;
          }

          if (pointDatas[i + 1] < 0) {
            pointDatas[i + 1] = ch + (pointDatas[i + 1] % ch);
          } else if (pointDatas[i + 1] > ch) {
            pointDatas[i + 1] = pointDatas[i + 1] % ch;
          }
          aposData[4 * 2 + i / 3 * 2] = pointDatas[i] * 2 / cw - 1;
          aposData[4 * 2 + i / 3 * 2 + 1] = pointDatas[i + 1] * 2 / ch - 1;
        }

        for (let i = 0, { length } = pointDatas; i < length; i = i + 3) {
          for (let j = i + 3; j < length; j = j + 3) {
            const dx = Math.abs(pointDatas[i] - pointDatas[j]);
            const dy = Math.abs(pointDatas[i + 1] - pointDatas[j + 1]);
            const d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));

            let alpha = d <= 300 ? 0.3 - ((0.3 * d) / 200) : 0;

            console.log(alpha)
          }
        }

        // requestAnimationFrame(draw);
        gl.uniform1f(timeUniform, ((Math.sin(Math.PI * 2 * Date.now() / 4000 - Math.PI / 2) + 1) / 2));
        gl.bufferData(gl.ARRAY_BUFFER, aposData, gl.STATIC_DRAW);

        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_BYTE, 0);
        gl.drawElements(gl.LINES, count - 6 - nodeCount, gl.UNSIGNED_BYTE, 5 + nodeCount);
        gl.drawElements(gl.POINTS, nodeCount, gl.UNSIGNED_BYTE, 6);

        dt = Date.now() - t0;
				t0 = Date.now();
      }
    </script>
  </body>
</html>
